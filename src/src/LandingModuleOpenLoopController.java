public class LandingModuleOpenLoopController {
    private double weight; // weight of landing module (kg)
    private Vector2D acceleration = new Vector2D(0, 0); // Acceleration on module (m/s^2)
    private Vector2D velocity; // Velocity of module (m/s)
    private Vector2D position; // Position of module (m)
    private double angle; // Landing module's angle of rotation

    private double mainForce = 2500; // Force generated by main thruster ((kg*m)/s^2)

    //Seconds conversion
	private static final int SEC_IN_MINUTE = 60;
  	private static final int SEC_IN_HOUR = SEC_IN_MINUTE * 60;
  	private static final int SEC_IN_DAY = SEC_IN_HOUR * 24;
  	private static final int SEC_IN_YEAR = 31556926;

    // Tolerance values
    private final double TOLPOSX = 0.1;
    private final double TOLANGLE = 0.02;
    private final double TOLVELX = 0.1;
    private final double TOLVELY = 0.1;
    private final double TOLROTATION = 0.01;

    private final double GRAVITYTITAN = -1.352; // gravity acceleration on titan

    private long time;
    private int numIterations;
    private double forceUsed;

    /** Constructs landing module
     *
     * @param weight weight of module
     * @param position position of module
     * @param velocity velocity of module
     */
    public LandingModuleOpenLoopController(double weight, Vector2D position, Vector2D velocity) {
        this.weight = weight;
        this.position = new Vector2D(position);
        this.velocity = new Vector2D(velocity);
    }

    /** This method calls on all necessary methods to simulate the landing
     *
     */
    public void updateModule(final long timestep) {
        numIterations = 0;
        forceUsed = 1351.9999;

		System.out.println("Starting landing from \nposition = " + position + "\nvelocity = " + velocity + "\n");

        while (!hasLanded()) {
            updateAcceleration(forceUsed); // Gravitational force and main thruster (+ air resistance in future?)
            updateVelocity(timestep);
            updatePosition(timestep);
            resetAcceleration();
            numIterations ++;
        }

        time = numIterations * timestep;

        System.out.println("Landing finished with \nposition = " + position + "\nspeed " + velocity + "\nand time = \n" + getTimeAsString(time));
    }

	/** Determines whether module has landed.
     * Will need to do something with tolerance values to determine this (Red booklet)
     * @return boolean value
     */
    private boolean hasLanded() {
        if (position.getY() <= 0.1) {
            return true;
        }

        return false;
    }

    /** Updates the acceleration of module
     *
     */
    private void updateAcceleration(double thrusterForce) {
        Vector2D gravity = new Vector2D(0, GRAVITYTITAN);
        acceleration.add(gravity);

        useMainThruster(thrusterForce);
    }

    /** Use the back thruster. Changes the modules acceleration
     *
     */
    public void useMainThruster(double thrusterForceExerted) {
	    // These are formulas from the booklet
	    // accel x = (mainForce/weight) * Math.sin(angle));
	    // accel y = (mainForce/weight) * Math.cos(angle));
	    // Different strengths of thruster
	    // Constant speed + landing
	    // Research max speed you want to reach
	    // At a certain altitude, increase power main thruster for a safe landing

        //System.out.println("Activated main thruster");
		Vector2D thrust = new Vector2D(Math.sin(Math.toRadians(angle)), Math.cos(Math.toRadians(angle))).multiply(thrusterForceExerted).divide(weight);
	    this.acceleration.add(thrust);
    }

    /** Updates the velocity of the module
     *
     */
    public void updateVelocity(double timestep) {
        Vector2D addAccel = new Vector2D(acceleration);
        addAccel.multiply(timestep);
        this.velocity.add(addAccel);
    }

    /** Updates the position of the module
     *
     */
    public void updatePosition(double timestep) {
        Vector2D addVel = new Vector2D(velocity);
        addVel.multiply(timestep);
        Vector2D addAccel = new Vector2D(acceleration);
        addAccel.multiply((.5*timestep*timestep));
        this.position.add(addVel);
        this.position.add(addAccel);
    }

    /** Sets acceleration back to 0
     *
     */
    public void resetAcceleration() {
    	this.acceleration = new Vector2D(0,0);
    }

    /** Mainly for debugging purposes, could be deleted in the end product

		@param time, a given number of seconds

		@return a nicely formatted string expressing the time parameter in years, days, minutes and seconds
	*/
	private String getTimeAsString (long time) {
		long years = time / SEC_IN_YEAR;
    	long days = (time % SEC_IN_YEAR) / SEC_IN_DAY;
    	long hours = ((time % SEC_IN_YEAR) % SEC_IN_DAY) / SEC_IN_HOUR;
    	long minutes =  (((time % SEC_IN_YEAR) % SEC_IN_DAY) % SEC_IN_HOUR) / SEC_IN_MINUTE;
    	long seconds =  (((time % SEC_IN_YEAR) % SEC_IN_DAY) % SEC_IN_HOUR) % SEC_IN_MINUTE;
    	return String.format("Years:%08d, Days:%03d, Hours:%02d, Minutes:%02d, Seconds:%02d", years, days, hours, minutes, seconds);
	}
}
